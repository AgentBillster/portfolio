{"ast":null,"code":"import { useSharedValue } from 'react-native-reanimated';\nimport { useRef } from 'react';\nconst fallback = () => ({});\n/**\n * A hook that acts like `useAnimationState`, except that it allows for dynamic values rather than static variants.\n *\n * This is useful when you want to update styles on the fly the way you do with `useState`.\n *\n * You can change the state by calling `state.animateTo()`, and access the current state by calling `state.current`.\n *\n * This hook has high performance, triggers no state changes, and runs fully on the native thread!\n *\n * ```js\n * const dynamicAnimation = useDynamicAnimation({ opacity: 0 })\n *\n * const onPress = () => {\n *   dynamicAnimation.animateTo({ opacity: 1 })\n * }\n *\n * const onMergeStyle = () => {\n *   // or, merge your styles\n *   // this uses the previous state, like useState from react\n *   dynamicAnimation.animateTo((current) => ({ ...current, scale: 1 }))\n *\n *   // you can also synchronously read the current value\n *   // these two options are the same!\n *   dynamicAnimation.animateTo({ ...dynamicAnimation.current, scale: 1 })\n * }\n * ```\n *\n * @param initialState A function that returns your initial style. Similar to `useState`'s initial style.\n */\nexport default function useDynamicAnimation() {\n  let initialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : fallback;\n  const activeStyle = useRef({\n    value: null\n  });\n  if (activeStyle.current.value === null) {\n    // use a .value to be certain it's never been set\n    activeStyle.current.value = initialState();\n  }\n  const __state = useSharedValue(activeStyle.current.value);\n  const controller = useRef();\n  if (controller.current == null) {\n    controller.current = {\n      __state,\n      get current() {\n        return __state.value;\n      },\n      animateTo(nextStateOrFunction) {\n        'worklet';\n\n        const nextStyle = typeof nextStateOrFunction === 'function' ? nextStateOrFunction(__state.value) : nextStateOrFunction;\n        __state.value = nextStyle;\n      }\n    };\n  }\n  return controller.current;\n}","map":{"version":3,"mappings":"AACA,SAASA,cAAc,QAAQ,yBAAyB;AACxD,SAASC,MAAM,QAAQ,OAAO;AAI9B,MAAMC,QAAQ,GAAG,OAAO,EAAE,CAAC;AAE3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,eAAc,SAAUC,mBAAmB,GACJ;EAAA,IAArCC,mFAA6BF,QAAQ;EAErC,MAAMG,WAAW,GAAGJ,MAAM,CAA8B;IACtDK,KAAK,EAAE;GACR,CAAC;EACF,IAAID,WAAW,CAACE,OAAO,CAACD,KAAK,KAAK,IAAI,EAAE;IACtC;IACAD,WAAW,CAACE,OAAO,CAACD,KAAK,GAAGF,YAAY,EAAE;;EAG5C,MAAMI,OAAO,GAAGR,cAAc,CAACK,WAAW,CAACE,OAAO,CAACD,KAAK,CAAC;EAEzD,MAAMG,UAAU,GAAGR,MAAM,EAA4B;EAErD,IAAIQ,UAAU,CAACF,OAAO,IAAI,IAAI,EAAE;IAC9BE,UAAU,CAACF,OAAO,GAAG;MACnBC,OAAO;MACP,IAAID,OAAO;QACT,OAAOC,OAAO,CAACF,KAAK;MACtB,CAAC;MACDI,SAAS,CAACC,mBAAmB;QAC3B,SAAS;;QAET,MAAMC,SAAS,GACb,OAAOD,mBAAmB,KAAK,UAAU,GACrCA,mBAAmB,CAACH,OAAO,CAACF,KAAK,CAAC,GAClCK,mBAAmB;QAEzBH,OAAO,CAACF,KAAK,GAAGM,SAAS;MAC3B;KACD;;EAGH,OAAOH,UAAU,CAACF,OAAmC;AACvD","names":["useSharedValue","useRef","fallback","useDynamicAnimation","initialState","activeStyle","value","current","__state","controller","animateTo","nextStateOrFunction","nextStyle"],"sources":["C:\\Users\\13093\\codestuff\\portfolio\\node_modules\\moti\\src\\core\\use-dynamic-animation\\index.ts"],"sourcesContent":["import type { DynamicStyleProp, UseDynamicAnimationState } from '../types'\nimport { useSharedValue } from 'react-native-reanimated'\nimport { useRef } from 'react'\n\ntype InitialState = () => DynamicStyleProp\n\nconst fallback = () => ({})\n\n/**\n * A hook that acts like `useAnimationState`, except that it allows for dynamic values rather than static variants.\n *\n * This is useful when you want to update styles on the fly the way you do with `useState`.\n *\n * You can change the state by calling `state.animateTo()`, and access the current state by calling `state.current`.\n *\n * This hook has high performance, triggers no state changes, and runs fully on the native thread!\n *\n * ```js\n * const dynamicAnimation = useDynamicAnimation({ opacity: 0 })\n *\n * const onPress = () => {\n *   dynamicAnimation.animateTo({ opacity: 1 })\n * }\n *\n * const onMergeStyle = () => {\n *   // or, merge your styles\n *   // this uses the previous state, like useState from react\n *   dynamicAnimation.animateTo((current) => ({ ...current, scale: 1 }))\n *\n *   // you can also synchronously read the current value\n *   // these two options are the same!\n *   dynamicAnimation.animateTo({ ...dynamicAnimation.current, scale: 1 })\n * }\n * ```\n *\n * @param initialState A function that returns your initial style. Similar to `useState`'s initial style.\n */\nexport default function useDynamicAnimation(\n  initialState: InitialState = fallback\n) {\n  const activeStyle = useRef<{ value: DynamicStyleProp }>({\n    value: null as any,\n  })\n  if (activeStyle.current.value === null) {\n    // use a .value to be certain it's never been set\n    activeStyle.current.value = initialState()\n  }\n\n  const __state = useSharedValue(activeStyle.current.value)\n\n  const controller = useRef<UseDynamicAnimationState>()\n\n  if (controller.current == null) {\n    controller.current = {\n      __state,\n      get current(): DynamicStyleProp {\n        return __state.value\n      },\n      animateTo(nextStateOrFunction) {\n        'worklet'\n\n        const nextStyle =\n          typeof nextStateOrFunction === 'function'\n            ? nextStateOrFunction(__state.value)\n            : nextStateOrFunction\n\n        __state.value = nextStyle\n      },\n    }\n  }\n\n  return controller.current as UseDynamicAnimationState\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}