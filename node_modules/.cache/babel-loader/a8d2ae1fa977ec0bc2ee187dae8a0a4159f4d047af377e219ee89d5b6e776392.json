{"ast":null,"code":"export default class MapperRegistry {\n  constructor(module) {\n    this.sortedMappers = [];\n    this.mappers = new Map();\n    this.updatedSinceLastExecute = false;\n    this._module = module;\n  }\n  startMapper(mapper) {\n    this.mappers.set(mapper.id, mapper);\n    this.updatedSinceLastExecute = true;\n    return mapper.id;\n  }\n  stopMapper(id) {\n    this.mappers.delete(id);\n    this.updatedSinceLastExecute = true;\n  }\n  execute() {\n    if (this.updatedSinceLastExecute) {\n      this.updateOrder();\n      this.updatedSinceLastExecute = false;\n    }\n    for (let i = 0, len = this.sortedMappers.length; i < len; ++i) {\n      const mapper = this.sortedMappers[i];\n      if (mapper.dirty) {\n        mapper.execute();\n      }\n    }\n  }\n  updateOrder() {\n    const nodes = [...this.mappers.values()].map(mapper => new Node(mapper));\n    const mappersById = {};\n    this.mappers.forEach(mapper => {\n      mappersById[mapper.id] = mapper;\n    });\n    // create a graph from array of nodes\n    for (let i = 0, nodesLen = nodes.length; i < nodesLen; ++i) {\n      const node = nodes[i];\n      if (node.mapper.outputs.length === 0) {\n        continue;\n      }\n      for (let j = 0; j < nodesLen; ++j) {\n        const restNode = nodes[j];\n        if (i === j || restNode.mapper.inputs.length === 0) {\n          continue;\n        }\n        for (let outi = 0, outputsLen = node.mapper.outputs.length; outi < outputsLen; ++outi) {\n          for (let resti = 0, restLen = restNode.mapper.inputs.length; resti < restLen; ++resti) {\n            if (node.mapper.outputs[outi]._id === restNode.mapper.inputs[resti]._id) {\n              node.children.push(restNode);\n            }\n          }\n        }\n      }\n    }\n    const post = {};\n    let postCounter = 1;\n    const dfs = node => {\n      const index = nodes.indexOf(node);\n      if (index === -1) {\n        // this node has already been handled\n        return;\n      }\n      ++postCounter;\n      nodes.splice(index, 1);\n      if (node.children.length === 0 && nodes.length > 0) {\n        post[node.mapper.id] = postCounter++;\n        dfs(nodes[0]);\n        return;\n      }\n      for (let i = 0, len = node.children.length; i < len; ++i) {\n        dfs(node.children[i]);\n      }\n      post[node.mapper.id] = postCounter++;\n    };\n    while (nodes.length) dfs(nodes[0]);\n    const postArray = Object.keys(post).map(key => {\n      const num = parseInt(key);\n      return [num, post[num]];\n    });\n    postArray.sort((a, b) => {\n      return b[1] - a[1];\n    });\n    // clear sorted mappers\n    this.sortedMappers = [];\n    for (let i = 0, len = postArray.length; i < len; ++i) {\n      const [id] = postArray[i];\n      this.sortedMappers.push(mappersById[id]);\n    }\n  }\n  get needRunOnRender() {\n    return this.updatedSinceLastExecute;\n  }\n}\nclass Node {\n  constructor(mapper) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.mapper = mapper;\n    this.children = children;\n  }\n}","map":{"version":3,"names":["MapperRegistry","constructor","module","sortedMappers","mappers","Map","updatedSinceLastExecute","_module","startMapper","mapper","set","id","stopMapper","delete","execute","updateOrder","i","len","length","dirty","nodes","values","map","Node","mappersById","forEach","nodesLen","node","outputs","j","restNode","inputs","outi","outputsLen","resti","restLen","_id","children","push","post","postCounter","dfs","index","indexOf","splice","postArray","Object","keys","key","num","parseInt","sort","a","b","needRunOnRender"],"sources":["C:/Users/13093/codestuff/portfolio/node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/MapperRegistry.js"],"sourcesContent":["export default class MapperRegistry {\n    constructor(module) {\n        this.sortedMappers = [];\n        this.mappers = new Map();\n        this.updatedSinceLastExecute = false;\n        this._module = module;\n    }\n    startMapper(mapper) {\n        this.mappers.set(mapper.id, mapper);\n        this.updatedSinceLastExecute = true;\n        return mapper.id;\n    }\n    stopMapper(id) {\n        this.mappers.delete(id);\n        this.updatedSinceLastExecute = true;\n    }\n    execute() {\n        if (this.updatedSinceLastExecute) {\n            this.updateOrder();\n            this.updatedSinceLastExecute = false;\n        }\n        for (let i = 0, len = this.sortedMappers.length; i < len; ++i) {\n            const mapper = this.sortedMappers[i];\n            if (mapper.dirty) {\n                mapper.execute();\n            }\n        }\n    }\n    updateOrder() {\n        const nodes = [...this.mappers.values()].map((mapper) => new Node(mapper));\n        const mappersById = {};\n        this.mappers.forEach((mapper) => {\n            mappersById[mapper.id] = mapper;\n        });\n        // create a graph from array of nodes\n        for (let i = 0, nodesLen = nodes.length; i < nodesLen; ++i) {\n            const node = nodes[i];\n            if (node.mapper.outputs.length === 0) {\n                continue;\n            }\n            for (let j = 0; j < nodesLen; ++j) {\n                const restNode = nodes[j];\n                if (i === j || restNode.mapper.inputs.length === 0) {\n                    continue;\n                }\n                for (let outi = 0, outputsLen = node.mapper.outputs.length; outi < outputsLen; ++outi) {\n                    for (let resti = 0, restLen = restNode.mapper.inputs.length; resti < restLen; ++resti) {\n                        if (node.mapper.outputs[outi]._id ===\n                            restNode.mapper.inputs[resti]._id) {\n                            node.children.push(restNode);\n                        }\n                    }\n                }\n            }\n        }\n        const post = {};\n        let postCounter = 1;\n        const dfs = (node) => {\n            const index = nodes.indexOf(node);\n            if (index === -1) {\n                // this node has already been handled\n                return;\n            }\n            ++postCounter;\n            nodes.splice(index, 1);\n            if (node.children.length === 0 && nodes.length > 0) {\n                post[node.mapper.id] = postCounter++;\n                dfs(nodes[0]);\n                return;\n            }\n            for (let i = 0, len = node.children.length; i < len; ++i) {\n                dfs(node.children[i]);\n            }\n            post[node.mapper.id] = postCounter++;\n        };\n        while (nodes.length)\n            dfs(nodes[0]);\n        const postArray = Object.keys(post).map((key) => {\n            const num = parseInt(key);\n            return [num, post[num]];\n        });\n        postArray.sort((a, b) => {\n            return b[1] - a[1];\n        });\n        // clear sorted mappers\n        this.sortedMappers = [];\n        for (let i = 0, len = postArray.length; i < len; ++i) {\n            const [id] = postArray[i];\n            this.sortedMappers.push(mappersById[id]);\n        }\n    }\n    get needRunOnRender() {\n        return this.updatedSinceLastExecute;\n    }\n}\nclass Node {\n    constructor(mapper, children = []) {\n        this.mapper = mapper;\n        this.children = children;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}