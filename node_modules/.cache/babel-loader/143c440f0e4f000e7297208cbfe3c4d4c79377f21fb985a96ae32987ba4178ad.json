{"ast":null,"code":"import AnimatedNode from './AnimatedNode';\nimport { val } from '../val';\nimport ReanimatedModule from '../../ReanimatedModule';\nimport invariant from 'invariant';\nfunction sanitizeValue(value) {\n  return value === null || value === undefined || typeof value === 'string' ? value : Number(value);\n}\nconst CONSTANT_VALUES = new Map();\nfunction initializeConstantValues() {\n  if (CONSTANT_VALUES.size !== 0) {\n    return;\n  }\n  [0, -1, 1, -2, 2].forEach(v => CONSTANT_VALUES.set(v, new InternalAnimatedValue(v, true)));\n}\n\n/**\n * This class has been made internal in order to omit dependencies' cycles which\n * were caused by imperative setValue and interpolate – they are currently exposed with AnimatedValue.js\n */\nexport default class InternalAnimatedValue extends AnimatedNode {\n  static valueForConstant(number) {\n    initializeConstantValues();\n    return CONSTANT_VALUES.get(number) || new InternalAnimatedValue(number, true);\n  }\n  constructor(value) {\n    let constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    invariant(value !== null, 'Animated.Value cannot be set to the null');\n    super({\n      type: 'value',\n      value: sanitizeValue(value)\n    });\n    this._startingValue = this._value = value;\n    this._animation = null;\n    this._constant = constant;\n  }\n  __detach() {\n    if (!this._constant) {\n      if (ReanimatedModule.getValue) {\n        ReanimatedModule.getValue(this.__nodeID, val => this.__nodeConfig.value = val);\n      } else {\n        this.__nodeConfig.value = this.__getValue();\n      }\n    }\n    this.__detachAnimation(this._animation);\n    super.__detach();\n  }\n  __detachAnimation(animation) {\n    animation && animation.__detach();\n    if (this._animation === animation) {\n      this._animation = null;\n    }\n  }\n  __attachAnimation(animation) {\n    this.__detachAnimation(this._animation);\n    this._animation = animation;\n  }\n  __onEvaluate() {\n    if (this.__inputNodes && this.__inputNodes.length) {\n      this.__inputNodes.forEach(val);\n    }\n    return this._value;\n  }\n\n  // AnimatedValue will override this method to modify the value of a native node.\n  setValue(value) {\n    this.__detachAnimation(this._animation);\n    this._updateValue(value);\n  }\n  _updateValue(value) {\n    this._value = value;\n    this.__forceUpdateCache(value);\n  }\n}","map":{"version":3,"names":["AnimatedNode","val","ReanimatedModule","invariant","sanitizeValue","value","undefined","Number","CONSTANT_VALUES","Map","initializeConstantValues","size","forEach","v","set","InternalAnimatedValue","valueForConstant","number","get","constructor","constant","type","_startingValue","_value","_animation","_constant","__detach","getValue","__nodeID","__nodeConfig","__getValue","__detachAnimation","animation","__attachAnimation","__onEvaluate","__inputNodes","length","setValue","_updateValue","__forceUpdateCache"],"sources":["C:/Users/13093/codestuff/portfolio/node_modules/react-native-reanimated/lib/reanimated1/core/InternalAnimatedValue.js"],"sourcesContent":["import AnimatedNode from './AnimatedNode';\nimport { val } from '../val';\nimport ReanimatedModule from '../../ReanimatedModule';\nimport invariant from 'invariant';\n\nfunction sanitizeValue(value) {\n  return value === null || value === undefined || typeof value === 'string'\n    ? value\n    : Number(value);\n}\n\nconst CONSTANT_VALUES = new Map();\n\nfunction initializeConstantValues() {\n  if (CONSTANT_VALUES.size !== 0) {\n    return;\n  }\n  [0, -1, 1, -2, 2].forEach((v) =>\n    CONSTANT_VALUES.set(v, new InternalAnimatedValue(v, true))\n  );\n}\n\n/**\n * This class has been made internal in order to omit dependencies' cycles which\n * were caused by imperative setValue and interpolate – they are currently exposed with AnimatedValue.js\n */\nexport default class InternalAnimatedValue extends AnimatedNode {\n  static valueForConstant(number) {\n    initializeConstantValues();\n    return (\n      CONSTANT_VALUES.get(number) || new InternalAnimatedValue(number, true)\n    );\n  }\n\n  constructor(value, constant = false) {\n    invariant(value !== null, 'Animated.Value cannot be set to the null');\n    super({ type: 'value', value: sanitizeValue(value) });\n    this._startingValue = this._value = value;\n    this._animation = null;\n    this._constant = constant;\n  }\n\n  __detach() {\n    if (!this._constant) {\n      if (ReanimatedModule.getValue) {\n        ReanimatedModule.getValue(\n          this.__nodeID,\n          (val) => (this.__nodeConfig.value = val)\n        );\n      } else {\n        this.__nodeConfig.value = this.__getValue();\n      }\n    }\n    this.__detachAnimation(this._animation);\n    super.__detach();\n  }\n\n  __detachAnimation(animation) {\n    animation && animation.__detach();\n    if (this._animation === animation) {\n      this._animation = null;\n    }\n  }\n\n  __attachAnimation(animation) {\n    this.__detachAnimation(this._animation);\n    this._animation = animation;\n  }\n\n  __onEvaluate() {\n    if (this.__inputNodes && this.__inputNodes.length) {\n      this.__inputNodes.forEach(val);\n    }\n    return this._value;\n  }\n\n  // AnimatedValue will override this method to modify the value of a native node.\n  setValue(value) {\n    this.__detachAnimation(this._animation);\n    this._updateValue(value);\n  }\n\n  _updateValue(value) {\n    this._value = value;\n    this.__forceUpdateCache(value);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}