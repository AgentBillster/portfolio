{"ast":null,"code":"import { PresenceContext, usePresence } from 'framer-motion';\nimport { useCallback, useContext, useEffect } from 'react';\nimport { useAnimatedStyle, useSharedValue, withDecay, withSpring, withTiming, withDelay, withRepeat, withSequence, runOnJS } from 'react-native-reanimated';\nimport { PackageName } from './constants/package-name';\nconst debug = function () {\n  'worklet';\n\n  // @ts-expect-error moti\n  if (!global.shouldDebugMoti) {\n    return;\n  }\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  if (args) {\n    // hi\n  }\n  console.log('[moti]', ...args);\n};\nconst isColor = styleKey => {\n  'worklet';\n\n  const keys = {\n    backgroundColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true,\n    borderRightColor: true,\n    borderTopColor: true,\n    color: true,\n    shadowColor: true,\n    borderColor: true,\n    borderEndColor: true,\n    borderStartColor: true\n  };\n  return Boolean(keys[styleKey]);\n};\nconst isTransform = styleKey => {\n  'worklet';\n\n  const transforms = {\n    perspective: true,\n    rotate: true,\n    rotateX: true,\n    rotateY: true,\n    rotateZ: true,\n    scale: true,\n    scaleX: true,\n    scaleY: true,\n    translateX: true,\n    translateY: true,\n    skewX: true,\n    skewY: true\n  };\n  return Boolean(transforms[styleKey]);\n};\nfunction animationDelay(_key, transition, defaultDelay) {\n  'worklet';\n\n  const key = _key;\n  let delayMs = defaultDelay;\n  if (transition?.[key]?.delay != null) {\n    delayMs = transition?.[key]?.delay;\n  } else if (transition?.delay != null) {\n    delayMs = transition.delay;\n  }\n  return {\n    delayMs\n  };\n}\nfunction animationConfig(styleProp, transition) {\n  'worklet';\n\n  const key = styleProp;\n  let repeatCount = 0;\n  let repeatReverse = true;\n  let animationType = 'spring';\n  if (isColor(key) || key === 'opacity') animationType = 'timing';\n  const styleSpecificTransition = transition?.[key];\n  // say that we're looking at `width`\n  // first, check if we have transition.width.type\n  if (styleSpecificTransition?.type) {\n    animationType = styleSpecificTransition.type;\n  } else if (transition?.type) {\n    // otherwise, fallback to transition.type\n    animationType = transition.type;\n  }\n  const loop = styleSpecificTransition?.loop ?? transition?.loop;\n  if (loop != null) {\n    repeatCount = loop ? -1 : 0;\n  }\n  if (styleSpecificTransition?.repeat != null) {\n    repeatCount = styleSpecificTransition?.repeat;\n  } else if (transition?.repeat != null) {\n    repeatCount = transition.repeat;\n  }\n  if (styleSpecificTransition?.repeatReverse != null) {\n    repeatReverse = styleSpecificTransition.repeatReverse;\n  } else if (transition?.repeatReverse != null) {\n    repeatReverse = transition.repeatReverse;\n  }\n  // debug({ loop, key, repeatCount, animationType })\n  let config = {};\n  // so sad, but fix it later :(\n  let animation = function () {\n    for (var _len2 = arguments.length, props = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n      props[_key3] = arguments[_key3];\n    }\n    return props;\n  };\n  if (animationType === 'timing') {\n    const duration = transition?.[key]?.duration ?? transition?.duration;\n    const easing = transition?.[key]?.easing ?? transition?.easing;\n    if (easing) {\n      config['easing'] = easing;\n    }\n    if (duration != null) {\n      config['duration'] = duration;\n    }\n    animation = withTiming;\n  } else if (animationType === 'spring') {\n    animation = withSpring;\n    config = {};\n    const configKeys = ['damping', 'mass', 'overshootClamping', 'restDisplacementThreshold', 'restSpeedThreshold', 'stiffness', 'velocity'];\n    for (const configKey of configKeys) {\n      const styleSpecificConfig = transition?.[key]?.[configKey];\n      const transitionConfigForKey = transition?.[configKey];\n      if (styleSpecificConfig != null) {\n        config[configKey] = styleSpecificConfig;\n      } else if (transitionConfigForKey != null) {\n        config[configKey] = transitionConfigForKey;\n      }\n    }\n  } else if (animationType === 'decay') {\n    animation = withDecay;\n    config = {\n      velocity: 2,\n      deceleration: 2\n    };\n    const configKeys = ['clamp', 'velocity', 'deceleration', 'velocityFactor'];\n    for (const configKey of configKeys) {\n      const styleSpecificConfig = transition?.[key]?.[configKey];\n      const transitionConfigForKey = transition?.[configKey];\n      if (styleSpecificConfig != null) {\n        config[configKey] = styleSpecificConfig;\n      } else if (transitionConfigForKey != null) {\n        config[configKey] = transitionConfigForKey;\n      }\n    }\n  }\n  return {\n    animation,\n    config,\n    repeatReverse,\n    repeatCount,\n    shouldRepeat: !!repeatCount\n  };\n}\nconst getSequenceArray = (sequenceKey, sequenceArray, delayMs, config, animation, callback) => {\n  'worklet';\n\n  const sequence = [];\n  for (const step of sequenceArray) {\n    const shouldPush = typeof step === 'object' ? step && step?.value != null && step?.value !== false : step != null && step !== false;\n    if (shouldPush) {\n      let stepDelay = delayMs;\n      let stepValue = step;\n      let stepConfig = Object.assign({}, config);\n      let stepAnimation = animation;\n      if (typeof step === 'object') {\n        // not allowed in Reanimated: { delay, value, ...transition } = step\n        const stepTransition = Object.assign({}, step);\n        delete stepTransition.delay;\n        delete stepTransition.value;\n        const {\n          config: inlineStepConfig,\n          animation\n        } = animationConfig(sequenceKey, stepTransition);\n        stepConfig = Object.assign({}, stepConfig, inlineStepConfig);\n        stepAnimation = animation;\n        if (step.delay != null) {\n          stepDelay = step.delay;\n        }\n        stepValue = step.value;\n      }\n      const sequenceValue = stepAnimation(stepValue, stepConfig, callback);\n      if (stepDelay != null) {\n        sequence.push(withDelay(stepDelay, sequenceValue));\n      } else {\n        sequence.push(sequenceValue);\n      }\n    }\n  }\n  return sequence;\n};\nexport function useMotify(_ref) {\n  let {\n    animate: animateProp,\n    from: fromProp = false,\n    transition: transitionProp,\n    exitTransition: exitTransitionProp,\n    delay: defaultDelay,\n    state,\n    stylePriority = 'animate',\n    onDidAnimate,\n    exit: exitProp,\n    animateInitialState = false\n  } = _ref;\n  const isMounted = useSharedValue(false);\n  const [isPresent, safeToUnmount] = usePresence();\n  const presence = useContext(PresenceContext);\n  const disableInitialAnimation = presence?.initial === false && !animateInitialState;\n  const custom = useCallback(() => {\n    'worklet';\n\n    return presence?.custom;\n  }, [presence]);\n  const reanimatedSafeToUnmount = useCallback(() => {\n    safeToUnmount?.();\n  }, [safeToUnmount]);\n  const reanimatedOnDidAnimated = useCallback(function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    onDidAnimate?.(...args);\n  }, [onDidAnimate]);\n  const hasExitStyle = Boolean(typeof exitProp === 'function' || typeof exitProp === 'object' && exitProp && Object.keys(exitProp).length > 0);\n  const style = useAnimatedStyle(() => {\n    const final = {\n      // initializing here fixes reanimated object.__defineProperty bug(?)\n      transform: []\n    };\n    const variantStyle = state?.__state?.value || {};\n    let animateStyle;\n    if (typeof animateProp == 'function') {\n      animateStyle = animateProp() || {};\n    } else if (animateProp && 'value' in animateProp) {\n      animateStyle = animateProp.value || {};\n    } else {\n      animateStyle = animateProp || {};\n    }\n    debug('style', animateStyle);\n    const initialStyle = fromProp || {};\n    let exitStyle = exitProp || {};\n    if (typeof exitStyle === 'function') {\n      exitStyle = exitStyle(custom());\n    }\n    const isExiting = !isPresent && hasExitStyle;\n    let mergedStyles = {};\n    if (stylePriority === 'state') {\n      mergedStyles = Object.assign({}, animateStyle, variantStyle);\n    } else {\n      mergedStyles = Object.assign({}, variantStyle, animateStyle);\n    }\n    if (!isMounted.value && !disableInitialAnimation && Object.keys(initialStyle).length) {\n      mergedStyles = initialStyle;\n    } else {\n      mergedStyles = Object.assign({}, initialStyle, mergedStyles);\n    }\n    if (isExiting && exitStyle) {\n      mergedStyles = Object.assign({}, exitStyle);\n    }\n    const exitingStyleProps = {};\n    Object.keys(exitStyle || {}).forEach(key => {\n      const disabledExitStyles = {\n        position: true,\n        zIndex: true\n      };\n      if (!disabledExitStyles[key]) {\n        exitingStyleProps[key] = true;\n      }\n    });\n    // allow shared values as transitions\n    let transition;\n    if (transitionProp && 'value' in transitionProp) {\n      transition = transitionProp.value;\n    } else {\n      transition = transitionProp;\n    }\n    // let the state prop drive transitions too\n    if (variantStyle.transition) {\n      transition = Object.assign({}, transition, variantStyle.transition);\n    }\n    if (isExiting && exitTransitionProp) {\n      let exitTransition;\n      if (exitTransitionProp && 'value' in exitTransitionProp) {\n        exitTransition = exitTransitionProp.value;\n      } else if (typeof exitTransitionProp == 'function') {\n        exitTransition = exitTransitionProp(custom());\n      } else {\n        exitTransition = exitTransitionProp;\n      }\n      transition = Object.assign({}, transition, exitTransition);\n    }\n    // need to use forEach to work with Hermes...https://github.com/nandorojo/moti/issues/214#issuecomment-1399055535\n    Object.keys(mergedStyles).forEach(key => {\n      const value = mergedStyles[key];\n      const {\n        animation,\n        config,\n        shouldRepeat,\n        repeatCount,\n        repeatReverse\n      } = animationConfig(key, transition);\n      const callback = (completed, recentValue) => {\n        if (onDidAnimate) {\n          runOnJS(reanimatedOnDidAnimated)(\n          // @ts-expect-error key is a string\n          key, completed, recentValue, {\n            attemptedValue: value\n          });\n        }\n        if (isExiting) {\n          exitingStyleProps[key] = false;\n          const areStylesExiting = Object.values(exitingStyleProps).some(Boolean);\n          // if this is true, then we've finished our exit animations\n          if (!areStylesExiting) {\n            runOnJS(reanimatedSafeToUnmount)();\n          }\n        }\n      };\n      let {\n        delayMs\n      } = animationDelay(key, transition, defaultDelay);\n      if (value == null || value === false) {\n        // skip missing values\n        // this is useful if you want to do {opacity: loading && 1}\n        // without this, those values will break I think\n        return;\n      }\n      if (key === 'transform') {\n        if (!Array.isArray(value)) {\n          console.error(`[${PackageName}]: Invalid transform value. Needs to be an array.`);\n        } else {\n          for (const transformObject of value) {\n            final['transform'] = final['transform'] || [];\n            const transformKey = Object.keys(transformObject)[0];\n            const transformValue = transformObject[transformKey];\n            const transform = {};\n            if (Array.isArray(transformValue)) {\n              // we have a sequence in this transform...\n              const sequence = getSequenceArray(transformKey, transformValue, delayMs, config, animation, callback);\n              if (sequence.length) {\n                let finalValue = withSequence(sequence[0], ...sequence.slice(1));\n                if (shouldRepeat) {\n                  finalValue = withRepeat(finalValue, repeatCount, repeatReverse);\n                }\n                transform[transformKey] = finalValue;\n              }\n            } else {\n              if (transition?.[transformKey]?.delay != null) {\n                delayMs = transition?.[transformKey]?.delay;\n              }\n              let finalValue = animation(transformValue, config, callback);\n              if (shouldRepeat) {\n                finalValue = withRepeat(finalValue, repeatCount, repeatReverse);\n              }\n              if (delayMs != null) {\n                transform[transformKey] = withDelay(delayMs, finalValue);\n              } else {\n                transform[transformKey] = finalValue;\n              }\n            }\n            if (Object.keys(transform).length) {\n              final['transform'].push(transform);\n            }\n          }\n        }\n      } else if (Array.isArray(value)) {\n        // we have a sequence\n        const sequence = getSequenceArray(key, value, delayMs, config, animation, callback);\n        let finalValue = withSequence(sequence[0], ...sequence.slice(1));\n        if (shouldRepeat) {\n          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);\n        }\n        if (isTransform(key)) {\n          // we have a sequence of transforms\n          final['transform'] = final['transform'] || [];\n          if (sequence.length) {\n            const transform = {};\n            transform[key] = finalValue;\n            // @ts-expect-error transform had the wrong type\n            final['transform'].push(transform);\n          }\n        } else {\n          // we have a normal sequence of items\n          // shadows not supported\n          if (sequence.length) {\n            final[key] = finalValue;\n          }\n        }\n      } else if (isTransform(key)) {\n        final['transform'] = final['transform'] || [];\n        // const transformKey = Object.keys(transformProp)[0]\n        // const transformValue = transformProp[transformKey]\n        if (transition?.[key]?.delay != null) {\n          delayMs = transition?.[key]?.delay;\n        }\n        const transform = {};\n        let finalValue = animation(value, config, callback);\n        if (shouldRepeat) {\n          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);\n        }\n        if (delayMs != null) {\n          transform[key] = withDelay(delayMs, finalValue);\n        } else {\n          transform[key] = finalValue;\n        }\n        // @ts-expect-error transform had the wrong type\n        final['transform'].push(transform);\n      } else if (typeof value === 'object') {\n        // shadows\n        final[key] = {};\n        for (const innerStyleKey in value || {}) {\n          let finalValue = animation(value, config, callback);\n          if (shouldRepeat) {\n            finalValue = withRepeat(finalValue, repeatCount, repeatReverse);\n          }\n          if (delayMs != null) {\n            final[key][innerStyleKey] = withDelay(delayMs, finalValue);\n          } else {\n            final[key][innerStyleKey] = finalValue;\n          }\n        }\n      } else {\n        let finalValue = animation(value, config, callback);\n        if (shouldRepeat) {\n          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);\n        }\n        if (delayMs != null && typeof delayMs === 'number') {\n          final[key] = withDelay(delayMs, finalValue);\n        } else {\n          final[key] = finalValue;\n        }\n      }\n    });\n    if (!final.transform?.length) {\n      delete final.transform;\n    }\n    return final;\n  }, [animateProp, custom, defaultDelay, disableInitialAnimation, exitProp, exitTransitionProp, fromProp, hasExitStyle, isMounted, isPresent, onDidAnimate, reanimatedOnDidAnimated, reanimatedSafeToUnmount, state, stylePriority, transitionProp]);\n  useEffect(() => {\n    isMounted.value = true;\n  }, [isMounted]);\n  useEffect(function allowUnMountIfMissingExit() {\n    if (!isPresent && !hasExitStyle) {\n      reanimatedSafeToUnmount();\n    }\n  }, [hasExitStyle, isPresent, reanimatedSafeToUnmount]);\n  return {\n    style\n  };\n}","map":{"version":3,"mappings":"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","names":["PresenceContext","usePresence","useCallback","useContext","useEffect","useAnimatedStyle","useSharedValue","withDecay","withSpring","withTiming","withDelay","withRepeat","withSequence","runOnJS","PackageName","debug","global","shouldDebugMoti","args","console","log","isColor","styleKey","keys","backgroundColor","borderBottomColor","borderLeftColor","borderRightColor","borderTopColor","color","shadowColor","borderColor","borderEndColor","borderStartColor","Boolean","isTransform","transforms","perspective","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","translateX","translateY","skewX","skewY","animationDelay","_key","transition","defaultDelay","key","delayMs","delay","animationConfig","styleProp","repeatCount","repeatReverse","animationType","styleSpecificTransition","type","loop","repeat","config","animation","props","duration","easing","configKeys","configKey","styleSpecificConfig","transitionConfigForKey","velocity","deceleration","shouldRepeat","getSequenceArray","sequenceKey","sequenceArray","callback","sequence","step","shouldPush","value","stepDelay","stepValue","stepConfig","Object","assign","stepAnimation","stepTransition","inlineStepConfig","sequenceValue","push","useMotify","animate","animateProp","from","fromProp","transitionProp","exitTransition","exitTransitionProp","state","stylePriority","onDidAnimate","exit","exitProp","animateInitialState","isMounted","isPresent","safeToUnmount","presence","disableInitialAnimation","initial","custom","reanimatedSafeToUnmount","reanimatedOnDidAnimated","hasExitStyle","length","style","final","transform","variantStyle","__state","animateStyle","initialStyle","exitStyle","isExiting","mergedStyles","exitingStyleProps","forEach","disabledExitStyles","position","zIndex","completed","recentValue","attemptedValue","areStylesExiting","values","some","Array","isArray","error","transformObject","transformKey","transformValue","finalValue","slice","innerStyleKey","allowUnMountIfMissingExit"],"sources":["C:\\Users\\13093\\codestuff\\portfolio\\node_modules\\moti\\src\\core\\use-motify.ts"],"sourcesContent":["import { PresenceContext, usePresence } from 'framer-motion'\nimport { useCallback, useContext, useEffect } from 'react'\nimport type { TransformsStyle } from 'react-native'\nimport {\n  useAnimatedStyle,\n  useSharedValue,\n  withDecay,\n  withSpring,\n  withTiming,\n  withDelay,\n  withRepeat,\n  withSequence,\n  runOnJS,\n} from 'react-native-reanimated'\nimport type {\n  WithDecayConfig,\n  WithSpringConfig,\n  WithTimingConfig,\n} from 'react-native-reanimated'\n\nimport { PackageName } from './constants/package-name'\nimport type {\n  MotiProps,\n  MotiTransition,\n  SequenceItem,\n  Transforms,\n  TransitionConfig,\n  WithTransition,\n} from './types'\n\nconst debug = (...args: any[]) => {\n  'worklet'\n\n  // @ts-expect-error moti\n  if (!global.shouldDebugMoti) {\n    return\n  }\n\n  if (args) {\n    // hi\n  }\n  console.log('[moti]', ...args)\n}\n\nconst isColor = (styleKey: string) => {\n  'worklet'\n  const keys = {\n    backgroundColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true,\n    borderRightColor: true,\n    borderTopColor: true,\n    color: true,\n    shadowColor: true,\n    borderColor: true,\n    borderEndColor: true,\n    borderStartColor: true,\n  }\n\n  return Boolean(keys[styleKey])\n}\n\nconst isTransform = (styleKey: string) => {\n  'worklet'\n\n  const transforms: Record<keyof Transforms, true> = {\n    perspective: true,\n    rotate: true,\n    rotateX: true,\n    rotateY: true,\n    rotateZ: true,\n    scale: true,\n    scaleX: true,\n    scaleY: true,\n    translateX: true,\n    translateY: true,\n    skewX: true,\n    skewY: true,\n  }\n\n  return Boolean(transforms[styleKey])\n}\n\nfunction animationDelay<Animate>(\n  _key: string,\n  transition: MotiTransition<Animate> | undefined,\n  defaultDelay?: number\n) {\n  'worklet'\n  const key = _key as keyof Animate\n  let delayMs: TransitionConfig['delay'] = defaultDelay\n\n  if (transition?.[key]?.delay != null) {\n    delayMs = transition?.[key]?.delay\n  } else if (transition?.delay != null) {\n    delayMs = transition.delay\n  }\n\n  return {\n    delayMs,\n  }\n}\n\nfunction animationConfig<Animate>(\n  styleProp: string,\n  transition: MotiTransition<Animate> | undefined\n) {\n  'worklet'\n\n  const key = styleProp as Extract<keyof Animate, string>\n  let repeatCount = 0\n  let repeatReverse = true\n\n  let animationType: Required<TransitionConfig>['type'] = 'spring'\n  if (isColor(key) || key === 'opacity') animationType = 'timing'\n\n  const styleSpecificTransition = transition?.[key]\n\n  // say that we're looking at `width`\n  // first, check if we have transition.width.type\n\n  if (styleSpecificTransition?.type) {\n    animationType = styleSpecificTransition.type\n  } else if (transition?.type) {\n    // otherwise, fallback to transition.type\n    animationType = transition.type\n  }\n\n  const loop = styleSpecificTransition?.loop ?? transition?.loop\n\n  if (loop != null) {\n    repeatCount = loop ? -1 : 0\n  }\n\n  if (styleSpecificTransition?.repeat != null) {\n    repeatCount = styleSpecificTransition?.repeat\n  } else if (transition?.repeat != null) {\n    repeatCount = transition.repeat\n  }\n\n  if (styleSpecificTransition?.repeatReverse != null) {\n    repeatReverse = styleSpecificTransition.repeatReverse\n  } else if (transition?.repeatReverse != null) {\n    repeatReverse = transition.repeatReverse\n  }\n\n  // debug({ loop, key, repeatCount, animationType })\n\n  let config = {}\n  // so sad, but fix it later :(\n  let animation = (...props: any): any => props\n\n  if (animationType === 'timing') {\n    const duration =\n      (transition?.[key] as WithTimingConfig | undefined)?.duration ??\n      (transition as WithTimingConfig | undefined)?.duration\n\n    const easing =\n      (transition?.[key] as WithTimingConfig | undefined)?.easing ??\n      (transition as WithTimingConfig | undefined)?.easing\n\n    if (easing) {\n      config['easing'] = easing\n    }\n    if (duration != null) {\n      config['duration'] = duration\n    }\n    animation = withTiming\n  } else if (animationType === 'spring') {\n    animation = withSpring\n    config = {} as WithSpringConfig\n    const configKeys: (keyof WithSpringConfig)[] = [\n      'damping',\n      'mass',\n      'overshootClamping',\n      'restDisplacementThreshold',\n      'restSpeedThreshold',\n      'stiffness',\n      'velocity',\n    ]\n    for (const configKey of configKeys) {\n      const styleSpecificConfig = transition?.[key]?.[configKey]\n      const transitionConfigForKey = transition?.[configKey]\n\n      if (styleSpecificConfig != null) {\n        config[configKey] = styleSpecificConfig\n      } else if (transitionConfigForKey != null) {\n        config[configKey] = transitionConfigForKey\n      }\n    }\n  } else if (animationType === 'decay') {\n    animation = withDecay\n    config = {\n      velocity: 2,\n      deceleration: 2,\n    }\n    const configKeys: (keyof WithDecayConfig)[] = [\n      'clamp',\n      'velocity',\n      'deceleration',\n      'velocityFactor',\n    ]\n    for (const configKey of configKeys) {\n      const styleSpecificConfig = transition?.[key]?.[configKey]\n      const transitionConfigForKey = transition?.[configKey]\n\n      if (styleSpecificConfig != null) {\n        config[configKey] = styleSpecificConfig\n      } else if (transitionConfigForKey != null) {\n        config[configKey] = transitionConfigForKey\n      }\n    }\n  }\n\n  return {\n    animation,\n    config,\n    repeatReverse,\n    repeatCount,\n    shouldRepeat: !!repeatCount,\n  }\n}\n\nconst getSequenceArray = (\n  sequenceKey: string,\n  sequenceArray: SequenceItem<any>[],\n  delayMs: number | undefined,\n  config: object,\n  animation: (...props: any) => any,\n  callback: (completed: boolean, value?: any) => void\n) => {\n  'worklet'\n\n  const sequence: any[] = []\n\n  for (const step of sequenceArray) {\n    const shouldPush =\n      typeof step === 'object'\n        ? step && step?.value != null && step?.value !== false\n        : step != null && step !== false\n    if (shouldPush) {\n      let stepDelay = delayMs\n      let stepValue = step\n      let stepConfig = Object.assign({}, config)\n      let stepAnimation = animation\n      if (typeof step === 'object') {\n        // not allowed in Reanimated: { delay, value, ...transition } = step\n        const stepTransition = Object.assign({}, step)\n\n        delete stepTransition.delay\n        delete stepTransition.value\n\n        const { config: inlineStepConfig, animation } = animationConfig(\n          sequenceKey,\n          stepTransition\n        )\n\n        stepConfig = Object.assign({}, stepConfig, inlineStepConfig)\n        stepAnimation = animation\n\n        if (step.delay != null) {\n          stepDelay = step.delay\n        }\n        stepValue = step.value\n      }\n\n      const sequenceValue = stepAnimation(stepValue, stepConfig, callback)\n      if (stepDelay != null) {\n        sequence.push(withDelay(stepDelay, sequenceValue))\n      } else {\n        sequence.push(sequenceValue)\n      }\n    }\n  }\n\n  return sequence\n}\n\nexport function useMotify<Animate>({\n  animate: animateProp,\n  from: fromProp = false,\n  transition: transitionProp,\n  exitTransition: exitTransitionProp,\n  delay: defaultDelay,\n  state,\n  stylePriority = 'animate',\n  onDidAnimate,\n  exit: exitProp,\n  animateInitialState = false,\n}: MotiProps<Animate>) {\n  const isMounted = useSharedValue(false)\n  const [isPresent, safeToUnmount] = usePresence()\n  const presence = useContext(PresenceContext)\n\n  const disableInitialAnimation =\n    presence?.initial === false && !animateInitialState\n  const custom = useCallback(() => {\n    'worklet'\n    return presence?.custom\n  }, [presence])\n\n  const reanimatedSafeToUnmount = useCallback(() => {\n    safeToUnmount?.()\n  }, [safeToUnmount])\n\n  const reanimatedOnDidAnimated = useCallback<NonNullable<typeof onDidAnimate>>(\n    (...args) => {\n      onDidAnimate?.(...args)\n    },\n    [onDidAnimate]\n  )\n\n  const hasExitStyle = Boolean(\n    typeof exitProp === 'function' ||\n      (typeof exitProp === 'object' &&\n        exitProp &&\n        Object.keys(exitProp).length > 0)\n  )\n\n  const style = useAnimatedStyle(() => {\n    const final = {\n      // initializing here fixes reanimated object.__defineProperty bug(?)\n      transform: [] as TransformsStyle['transform'],\n    }\n    const variantStyle: Animate & WithTransition = state?.__state?.value || {}\n\n    let animateStyle: Animate\n\n    if (typeof animateProp == 'function') {\n      animateStyle = (animateProp() || {}) as Animate\n    } else if (animateProp && 'value' in animateProp) {\n      animateStyle = (animateProp.value || {}) as Animate\n    } else {\n      animateStyle = (animateProp || {}) as Animate\n    }\n\n    debug('style', animateStyle)\n\n    const initialStyle = fromProp || {}\n    let exitStyle = exitProp || {}\n    if (typeof exitStyle === 'function') {\n      exitStyle = exitStyle(custom())\n    }\n\n    const isExiting = !isPresent && hasExitStyle\n\n    let mergedStyles: Animate = {} as Animate\n    if (stylePriority === 'state') {\n      mergedStyles = Object.assign({}, animateStyle, variantStyle)\n    } else {\n      mergedStyles = Object.assign({}, variantStyle, animateStyle)\n    }\n\n    if (\n      !isMounted.value &&\n      !disableInitialAnimation &&\n      Object.keys(initialStyle).length\n    ) {\n      mergedStyles = initialStyle as Animate\n    } else {\n      mergedStyles = Object.assign({}, initialStyle, mergedStyles)\n    }\n\n    if (isExiting && exitStyle) {\n      mergedStyles = Object.assign({}, exitStyle) as any\n    }\n\n    const exitingStyleProps: Record<string, boolean> = {}\n\n    Object.keys(exitStyle || {}).forEach((key) => {\n      const disabledExitStyles = {\n        position: true,\n        zIndex: true,\n      }\n      if (!disabledExitStyles[key]) {\n        exitingStyleProps[key] = true\n      }\n    })\n\n    // allow shared values as transitions\n    let transition: MotiTransition<Animate> | undefined\n    if (transitionProp && 'value' in transitionProp) {\n      transition = transitionProp.value\n    } else {\n      transition = transitionProp\n    }\n\n    // let the state prop drive transitions too\n    if (variantStyle.transition) {\n      transition = Object.assign({}, transition, variantStyle.transition)\n    }\n\n    if (isExiting && exitTransitionProp) {\n      let exitTransition: MotiTransition<Animate> | undefined\n      if (exitTransitionProp && 'value' in exitTransitionProp) {\n        exitTransition = exitTransitionProp.value\n      } else if (typeof exitTransitionProp == 'function') {\n        exitTransition = exitTransitionProp(custom())\n      } else {\n        exitTransition = exitTransitionProp\n      }\n\n      transition = Object.assign({}, transition, exitTransition)\n    }\n\n    // need to use forEach to work with Hermes...https://github.com/nandorojo/moti/issues/214#issuecomment-1399055535\n    Object.keys(mergedStyles).forEach((key) => {\n      const value = mergedStyles[key]\n\n      const {\n        animation,\n        config,\n        shouldRepeat,\n        repeatCount,\n        repeatReverse,\n      } = animationConfig(key, transition)\n\n      const callback: (completed: boolean, value?: any) => void = (\n        completed,\n        recentValue\n      ) => {\n        if (onDidAnimate) {\n          runOnJS(reanimatedOnDidAnimated)(\n            // @ts-expect-error key is a string\n            key,\n            completed,\n            recentValue,\n            {\n              attemptedValue: value,\n            }\n          )\n        }\n        if (isExiting) {\n          exitingStyleProps[key] = false\n          const areStylesExiting = Object.values(exitingStyleProps).some(\n            Boolean\n          )\n          // if this is true, then we've finished our exit animations\n          if (!areStylesExiting) {\n            runOnJS(reanimatedSafeToUnmount)()\n          }\n        }\n      }\n\n      let { delayMs } = animationDelay(key, transition, defaultDelay)\n\n      if (value == null || value === false) {\n        // skip missing values\n        // this is useful if you want to do {opacity: loading && 1}\n        // without this, those values will break I think\n        return\n      }\n\n      if (key === 'transform') {\n        if (!Array.isArray(value)) {\n          console.error(\n            `[${PackageName}]: Invalid transform value. Needs to be an array.`\n          )\n        } else {\n          for (const transformObject of value) {\n            final['transform'] = final['transform'] || []\n            const transformKey = Object.keys(transformObject)[0]\n            const transformValue = transformObject[transformKey]\n            const transform = {} as any\n\n            if (Array.isArray(transformValue)) {\n              // we have a sequence in this transform...\n              const sequence = getSequenceArray(\n                transformKey,\n                transformValue,\n                delayMs,\n                config,\n                animation,\n                callback\n              )\n\n              if (sequence.length) {\n                let finalValue = withSequence(sequence[0], ...sequence.slice(1))\n                if (shouldRepeat) {\n                  finalValue = withRepeat(\n                    finalValue,\n                    repeatCount,\n                    repeatReverse\n                  )\n                }\n                transform[transformKey] = finalValue\n              }\n            } else {\n              if (transition?.[transformKey]?.delay != null) {\n                delayMs = transition?.[transformKey]?.delay\n              }\n\n              let finalValue = animation(transformValue, config, callback)\n              if (shouldRepeat) {\n                finalValue = withRepeat(finalValue, repeatCount, repeatReverse)\n              }\n              if (delayMs != null) {\n                transform[transformKey] = withDelay(delayMs, finalValue)\n              } else {\n                transform[transformKey] = finalValue\n              }\n            }\n\n            if (Object.keys(transform).length) {\n              final['transform'].push(transform)\n            }\n          }\n        }\n      } else if (Array.isArray(value)) {\n        // we have a sequence\n\n        const sequence = getSequenceArray(\n          key,\n          value,\n          delayMs,\n          config,\n          animation,\n          callback\n        )\n        let finalValue = withSequence(sequence[0], ...sequence.slice(1))\n        if (shouldRepeat) {\n          finalValue = withRepeat(finalValue, repeatCount, repeatReverse)\n        }\n\n        if (isTransform(key)) {\n          // we have a sequence of transforms\n          final['transform'] = final['transform'] || []\n\n          if (sequence.length) {\n            const transform = {}\n\n            transform[key] = finalValue\n\n            // @ts-expect-error transform had the wrong type\n            final['transform'].push(transform)\n          }\n        } else {\n          // we have a normal sequence of items\n          // shadows not supported\n          if (sequence.length) {\n            final[key] = finalValue\n          }\n        }\n      } else if (isTransform(key)) {\n        final['transform'] = final['transform'] || []\n        // const transformKey = Object.keys(transformProp)[0]\n        // const transformValue = transformProp[transformKey]\n\n        if (transition?.[key]?.delay != null) {\n          delayMs = transition?.[key]?.delay\n        }\n\n        const transform = {}\n        let finalValue = animation(value, config, callback)\n        if (shouldRepeat) {\n          finalValue = withRepeat(finalValue, repeatCount, repeatReverse)\n        }\n        if (delayMs != null) {\n          transform[key] = withDelay(delayMs, finalValue)\n        } else {\n          transform[key] = finalValue\n        }\n\n        // @ts-expect-error transform had the wrong type\n        final['transform'].push(transform)\n      } else if (typeof value === 'object') {\n        // shadows\n        final[key] = {}\n        for (const innerStyleKey in value || {}) {\n          let finalValue = animation(value, config, callback)\n\n          if (shouldRepeat) {\n            finalValue = withRepeat(finalValue, repeatCount, repeatReverse)\n          }\n\n          if (delayMs != null) {\n            final[key][innerStyleKey] = withDelay(delayMs, finalValue)\n          } else {\n            final[key][innerStyleKey] = finalValue\n          }\n        }\n      } else {\n        let finalValue = animation(value, config, callback)\n        if (shouldRepeat) {\n          finalValue = withRepeat(finalValue, repeatCount, repeatReverse)\n        }\n\n        if (delayMs != null && typeof delayMs === 'number') {\n          final[key] = withDelay(delayMs, finalValue)\n        } else {\n          final[key] = finalValue\n        }\n      }\n    })\n\n    if (!final.transform?.length) {\n      delete final.transform\n    }\n\n    return final\n  }, [\n    animateProp,\n    custom,\n    defaultDelay,\n    disableInitialAnimation,\n    exitProp,\n    exitTransitionProp,\n    fromProp,\n    hasExitStyle,\n    isMounted,\n    isPresent,\n    onDidAnimate,\n    reanimatedOnDidAnimated,\n    reanimatedSafeToUnmount,\n    state,\n    stylePriority,\n    transitionProp,\n  ])\n\n  useEffect(() => {\n    isMounted.value = true\n  }, [isMounted])\n\n  useEffect(\n    function allowUnMountIfMissingExit() {\n      if (!isPresent && !hasExitStyle) {\n        reanimatedSafeToUnmount()\n      }\n    },\n    [hasExitStyle, isPresent, reanimatedSafeToUnmount]\n  )\n\n  return {\n    style,\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}