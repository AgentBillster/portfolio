{"ast":null,"code":"import AnimatedValue from '../core/InternalAnimatedValue';\nimport { createAnimatedSet as set } from '../core/AnimatedSet';\nimport { createAnimatedCall as call } from '../core/AnimatedCall';\nimport { createAnimatedAlways as always } from '../core/AnimatedAlways';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\n\n/**\n * evaluate given node and notify children\n * @param node - node to be evaluated\n * @param input - nodes (or one node) representing values which states input for node.\n * @param callback - after callback\n */\n\nexport function evaluateOnce(node) {\n  let input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let callback = arguments.length > 2 ? arguments[2] : undefined;\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  const done = new AnimatedValue(0);\n  const evalNode = cond(done, 0, call([node, set(done, 1)], () => {\n    callback && callback();\n    for (let i = 0; i < input.length; i++) {\n      input[i].__removeChild(alwaysNode);\n      alwaysNode.__detach();\n    }\n  }));\n  const alwaysNode = always(evalNode);\n  for (let i = 0; i < input.length; i++) {\n    input[i].__addChild(alwaysNode);\n    alwaysNode.__attach();\n  }\n}","map":{"version":3,"names":["AnimatedValue","createAnimatedSet","set","createAnimatedCall","call","createAnimatedAlways","always","createAnimatedCond","cond","evaluateOnce","node","input","callback","Array","isArray","done","evalNode","i","length","__removeChild","alwaysNode","__detach","__addChild","__attach"],"sources":["C:/Users/13093/codestuff/portfolio/node_modules/react-native-reanimated/lib/reanimated1/derived/evaluateOnce.js"],"sourcesContent":["import AnimatedValue from '../core/InternalAnimatedValue';\nimport { createAnimatedSet as set } from '../core/AnimatedSet';\nimport { createAnimatedCall as call } from '../core/AnimatedCall';\nimport { createAnimatedAlways as always } from '../core/AnimatedAlways';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\n\n/**\n * evaluate given node and notify children\n * @param node - node to be evaluated\n * @param input - nodes (or one node) representing values which states input for node.\n * @param callback - after callback\n */\n\nexport function evaluateOnce(node, input = [], callback) {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  const done = new AnimatedValue(0);\n  const evalNode = cond(\n    done,\n    0,\n    call([node, set(done, 1)], () => {\n      callback && callback();\n      for (let i = 0; i < input.length; i++) {\n        input[i].__removeChild(alwaysNode);\n        alwaysNode.__detach();\n      }\n    })\n  );\n  const alwaysNode = always(evalNode);\n  for (let i = 0; i < input.length; i++) {\n    input[i].__addChild(alwaysNode);\n    alwaysNode.__attach();\n  }\n}\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,+BAA+B;AACzD,SAASC,iBAAiB,IAAIC,GAAG,QAAQ,qBAAqB;AAC9D,SAASC,kBAAkB,IAAIC,IAAI,QAAQ,sBAAsB;AACjE,SAASC,oBAAoB,IAAIC,MAAM,QAAQ,wBAAwB;AACvE,SAASC,kBAAkB,IAAIC,IAAI,QAAQ,sBAAsB;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,YAAY,CAACC,IAAI,EAAwB;EAAA,IAAtBC,KAAK,uEAAG,EAAE;EAAA,IAAEC,QAAQ;EACrD,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;IACzBA,KAAK,GAAG,CAACA,KAAK,CAAC;EACjB;EACA,MAAMI,IAAI,GAAG,IAAIf,aAAa,CAAC,CAAC,CAAC;EACjC,MAAMgB,QAAQ,GAAGR,IAAI,CACnBO,IAAI,EACJ,CAAC,EACDX,IAAI,CAAC,CAACM,IAAI,EAAER,GAAG,CAACa,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM;IAC/BH,QAAQ,IAAIA,QAAQ,EAAE;IACtB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,KAAK,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;MACrCN,KAAK,CAACM,CAAC,CAAC,CAACE,aAAa,CAACC,UAAU,CAAC;MAClCA,UAAU,CAACC,QAAQ,EAAE;IACvB;EACF,CAAC,CAAC,CACH;EACD,MAAMD,UAAU,GAAGd,MAAM,CAACU,QAAQ,CAAC;EACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,KAAK,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;IACrCN,KAAK,CAACM,CAAC,CAAC,CAACK,UAAU,CAACF,UAAU,CAAC;IAC/BA,UAAU,CAACG,QAAQ,EAAE;EACvB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}