{"ast":null,"code":"import { hsvToColor, RGBtoHSV, rgbaColor, processColor, red, green, blue, opacity } from './Colors';\nimport { makeMutable } from './core';\nimport { interpolate } from './interpolation';\n// @ts-ignore JS file\nimport { Extrapolate } from '../reanimated1/derived';\nimport { useSharedValue } from './hook/useSharedValue';\nconst interpolateColorsHSV = (value, inputRange, colors, options) => {\n  'worklet';\n\n  let h = 0;\n  const {\n    useCorrectedHSVInterpolation = true\n  } = options;\n  if (useCorrectedHSVInterpolation) {\n    // if the difference between hues in a range is > 180 deg\n    // then move the hue at the right end of the range +/- 360 deg\n    // and add the next point in the original place + 0.00001 with original hue\n    // to not break the next range\n    const correctedInputRange = [inputRange[0]];\n    const originalH = colors.h;\n    const correctedH = [originalH[0]];\n    for (let i = 1; i < originalH.length; ++i) {\n      const d = originalH[i] - originalH[i - 1];\n      if (originalH[i] > originalH[i - 1] && d > 0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] - 1);\n        correctedH.push(originalH[i]);\n      } else if (originalH[i] < originalH[i - 1] && d < -0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] + 1);\n        correctedH.push(originalH[i]);\n      } else {\n        correctedInputRange.push(inputRange[i]);\n        correctedH.push(originalH[i]);\n      }\n    }\n    h = (interpolate(value, correctedInputRange, correctedH, Extrapolate.CLAMP) + 1) % 1;\n  } else {\n    h = interpolate(value, inputRange, colors.h, Extrapolate.CLAMP);\n  }\n  const s = interpolate(value, inputRange, colors.s, Extrapolate.CLAMP);\n  const v = interpolate(value, inputRange, colors.v, Extrapolate.CLAMP);\n  const a = interpolate(value, inputRange, colors.a, Extrapolate.CLAMP);\n  return hsvToColor(h, s, v, a);\n};\nconst toLinearSpace = (x, gamma) => {\n  'worklet';\n\n  return x.map(v => Math.pow(v / 255, gamma));\n};\nconst toGammaSpace = (x, gamma) => {\n  'worklet';\n\n  return Math.round(Math.pow(x, 1 / gamma) * 255);\n};\nconst interpolateColorsRGB = (value, inputRange, colors, options) => {\n  'worklet';\n\n  const {\n    gamma = 2.2\n  } = options;\n  let {\n    r: outputR,\n    g: outputG,\n    b: outputB\n  } = colors;\n  if (gamma !== 1) {\n    outputR = toLinearSpace(outputR, gamma);\n    outputG = toLinearSpace(outputG, gamma);\n    outputB = toLinearSpace(outputB, gamma);\n  }\n  const r = interpolate(value, inputRange, outputR, Extrapolate.CLAMP);\n  const g = interpolate(value, inputRange, outputG, Extrapolate.CLAMP);\n  const b = interpolate(value, inputRange, outputB, Extrapolate.CLAMP);\n  const a = interpolate(value, inputRange, colors.a, Extrapolate.CLAMP);\n  if (gamma === 1) {\n    return rgbaColor(r, g, b, a);\n  }\n  return rgbaColor(toGammaSpace(r, gamma), toGammaSpace(g, gamma), toGammaSpace(b, gamma), a);\n};\nconst getInterpolateRGB = colors => {\n  'worklet';\n\n  const r = [];\n  const g = [];\n  const b = [];\n  const a = [];\n  for (let i = 0; i < colors.length; ++i) {\n    const color = colors[i];\n    const processedColor = processColor(color);\n    // explicit check in case if processedColor is 0\n    if (processedColor !== null && processedColor !== undefined) {\n      r.push(red(processedColor));\n      g.push(green(processedColor));\n      b.push(blue(processedColor));\n      a.push(opacity(processedColor));\n    }\n  }\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n};\nconst getInterpolateHSV = colors => {\n  'worklet';\n\n  const h = [];\n  const s = [];\n  const v = [];\n  const a = [];\n  for (let i = 0; i < colors.length; ++i) {\n    const color = colors[i];\n    const processedColor = processColor(color);\n    if (typeof processedColor === 'number') {\n      const processedHSVColor = RGBtoHSV(red(processedColor), green(processedColor), blue(processedColor));\n      h.push(processedHSVColor.h);\n      s.push(processedHSVColor.s);\n      v.push(processedHSVColor.v);\n      a.push(opacity(processedColor));\n    }\n  }\n  return {\n    h,\n    s,\n    v,\n    a\n  };\n};\nexport const interpolateColor = function (value, inputRange, outputRange) {\n  'worklet';\n\n  let colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'RGB';\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  if (colorSpace === 'HSV') {\n    return interpolateColorsHSV(value, inputRange, getInterpolateHSV(outputRange), options);\n  } else if (colorSpace === 'RGB') {\n    return interpolateColorsRGB(value, inputRange, getInterpolateRGB(outputRange), options);\n  }\n  throw new Error(`Invalid color space provided: ${colorSpace}. Supported values are: ['RGB', 'HSV']`);\n};\nexport var ColorSpace;\n(function (ColorSpace) {\n  ColorSpace[ColorSpace[\"RGB\"] = 0] = \"RGB\";\n  ColorSpace[ColorSpace[\"HSV\"] = 1] = \"HSV\";\n})(ColorSpace || (ColorSpace = {}));\nexport function useInterpolateConfig(inputRange, outputRange) {\n  let colorSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ColorSpace.RGB;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return useSharedValue({\n    inputRange,\n    outputRange,\n    colorSpace,\n    cache: makeMutable(null),\n    options\n  });\n}\nexport const interpolateSharableColor = (value, interpolateConfig) => {\n  'worklet';\n\n  let colors = interpolateConfig.value.cache.value;\n  if (interpolateConfig.value.colorSpace === ColorSpace.RGB) {\n    if (!colors) {\n      colors = getInterpolateRGB(interpolateConfig.value.outputRange);\n      interpolateConfig.value.cache.value = colors;\n    }\n    return interpolateColorsRGB(value, interpolateConfig.value.inputRange, colors, interpolateConfig.value.options);\n  } else if (interpolateConfig.value.colorSpace === ColorSpace.HSV) {\n    if (!colors) {\n      colors = getInterpolateHSV(interpolateConfig.value.outputRange);\n      interpolateConfig.value.cache.value = colors;\n    }\n    return interpolateColorsHSV(value, interpolateConfig.value.inputRange, colors, interpolateConfig.value.options);\n  }\n  throw new Error(`Invalid color space provided: ${interpolateConfig.value.colorSpace}. Supported values are: ['RGB', 'HSV']`);\n};","map":{"version":3,"names":["hsvToColor","RGBtoHSV","rgbaColor","processColor","red","green","blue","opacity","makeMutable","interpolate","Extrapolate","useSharedValue","interpolateColorsHSV","value","inputRange","colors","options","h","useCorrectedHSVInterpolation","correctedInputRange","originalH","correctedH","i","length","d","push","CLAMP","s","v","a","toLinearSpace","x","gamma","map","Math","pow","toGammaSpace","round","interpolateColorsRGB","r","outputR","g","outputG","b","outputB","getInterpolateRGB","color","processedColor","undefined","getInterpolateHSV","processedHSVColor","interpolateColor","outputRange","colorSpace","Error","ColorSpace","useInterpolateConfig","RGB","cache","interpolateSharableColor","interpolateConfig","HSV"],"sources":["C:/Users/13093/codestuff/portfolio/node_modules/react-native-reanimated/lib/reanimated2/interpolateColor.js"],"sourcesContent":["import { hsvToColor, RGBtoHSV, rgbaColor, processColor, red, green, blue, opacity, } from './Colors';\nimport { makeMutable } from './core';\nimport { interpolate } from './interpolation';\n// @ts-ignore JS file\nimport { Extrapolate } from '../reanimated1/derived';\nimport { useSharedValue } from './hook/useSharedValue';\nconst interpolateColorsHSV = (value, inputRange, colors, options) => {\n    'worklet';\n    let h = 0;\n    const { useCorrectedHSVInterpolation = true } = options;\n    if (useCorrectedHSVInterpolation) {\n        // if the difference between hues in a range is > 180 deg\n        // then move the hue at the right end of the range +/- 360 deg\n        // and add the next point in the original place + 0.00001 with original hue\n        // to not break the next range\n        const correctedInputRange = [inputRange[0]];\n        const originalH = colors.h;\n        const correctedH = [originalH[0]];\n        for (let i = 1; i < originalH.length; ++i) {\n            const d = originalH[i] - originalH[i - 1];\n            if (originalH[i] > originalH[i - 1] && d > 0.5) {\n                correctedInputRange.push(inputRange[i]);\n                correctedInputRange.push(inputRange[i] + 0.00001);\n                correctedH.push(originalH[i] - 1);\n                correctedH.push(originalH[i]);\n            }\n            else if (originalH[i] < originalH[i - 1] && d < -0.5) {\n                correctedInputRange.push(inputRange[i]);\n                correctedInputRange.push(inputRange[i] + 0.00001);\n                correctedH.push(originalH[i] + 1);\n                correctedH.push(originalH[i]);\n            }\n            else {\n                correctedInputRange.push(inputRange[i]);\n                correctedH.push(originalH[i]);\n            }\n        }\n        h =\n            (interpolate(value, correctedInputRange, correctedH, Extrapolate.CLAMP) +\n                1) %\n                1;\n    }\n    else {\n        h = interpolate(value, inputRange, colors.h, Extrapolate.CLAMP);\n    }\n    const s = interpolate(value, inputRange, colors.s, Extrapolate.CLAMP);\n    const v = interpolate(value, inputRange, colors.v, Extrapolate.CLAMP);\n    const a = interpolate(value, inputRange, colors.a, Extrapolate.CLAMP);\n    return hsvToColor(h, s, v, a);\n};\nconst toLinearSpace = (x, gamma) => {\n    'worklet';\n    return x.map((v) => Math.pow(v / 255, gamma));\n};\nconst toGammaSpace = (x, gamma) => {\n    'worklet';\n    return Math.round(Math.pow(x, 1 / gamma) * 255);\n};\nconst interpolateColorsRGB = (value, inputRange, colors, options) => {\n    'worklet';\n    const { gamma = 2.2 } = options;\n    let { r: outputR, g: outputG, b: outputB } = colors;\n    if (gamma !== 1) {\n        outputR = toLinearSpace(outputR, gamma);\n        outputG = toLinearSpace(outputG, gamma);\n        outputB = toLinearSpace(outputB, gamma);\n    }\n    const r = interpolate(value, inputRange, outputR, Extrapolate.CLAMP);\n    const g = interpolate(value, inputRange, outputG, Extrapolate.CLAMP);\n    const b = interpolate(value, inputRange, outputB, Extrapolate.CLAMP);\n    const a = interpolate(value, inputRange, colors.a, Extrapolate.CLAMP);\n    if (gamma === 1) {\n        return rgbaColor(r, g, b, a);\n    }\n    return rgbaColor(toGammaSpace(r, gamma), toGammaSpace(g, gamma), toGammaSpace(b, gamma), a);\n};\nconst getInterpolateRGB = (colors) => {\n    'worklet';\n    const r = [];\n    const g = [];\n    const b = [];\n    const a = [];\n    for (let i = 0; i < colors.length; ++i) {\n        const color = colors[i];\n        const processedColor = processColor(color);\n        // explicit check in case if processedColor is 0\n        if (processedColor !== null && processedColor !== undefined) {\n            r.push(red(processedColor));\n            g.push(green(processedColor));\n            b.push(blue(processedColor));\n            a.push(opacity(processedColor));\n        }\n    }\n    return { r, g, b, a };\n};\nconst getInterpolateHSV = (colors) => {\n    'worklet';\n    const h = [];\n    const s = [];\n    const v = [];\n    const a = [];\n    for (let i = 0; i < colors.length; ++i) {\n        const color = colors[i];\n        const processedColor = processColor(color);\n        if (typeof processedColor === 'number') {\n            const processedHSVColor = RGBtoHSV(red(processedColor), green(processedColor), blue(processedColor));\n            h.push(processedHSVColor.h);\n            s.push(processedHSVColor.s);\n            v.push(processedHSVColor.v);\n            a.push(opacity(processedColor));\n        }\n    }\n    return { h, s, v, a };\n};\nexport const interpolateColor = (value, inputRange, outputRange, colorSpace = 'RGB', options = {}) => {\n    'worklet';\n    if (colorSpace === 'HSV') {\n        return interpolateColorsHSV(value, inputRange, getInterpolateHSV(outputRange), options);\n    }\n    else if (colorSpace === 'RGB') {\n        return interpolateColorsRGB(value, inputRange, getInterpolateRGB(outputRange), options);\n    }\n    throw new Error(`Invalid color space provided: ${colorSpace}. Supported values are: ['RGB', 'HSV']`);\n};\nexport var ColorSpace;\n(function (ColorSpace) {\n    ColorSpace[ColorSpace[\"RGB\"] = 0] = \"RGB\";\n    ColorSpace[ColorSpace[\"HSV\"] = 1] = \"HSV\";\n})(ColorSpace || (ColorSpace = {}));\nexport function useInterpolateConfig(inputRange, outputRange, colorSpace = ColorSpace.RGB, options = {}) {\n    return useSharedValue({\n        inputRange,\n        outputRange,\n        colorSpace,\n        cache: makeMutable(null),\n        options,\n    });\n}\nexport const interpolateSharableColor = (value, interpolateConfig) => {\n    'worklet';\n    let colors = interpolateConfig.value.cache.value;\n    if (interpolateConfig.value.colorSpace === ColorSpace.RGB) {\n        if (!colors) {\n            colors = getInterpolateRGB(interpolateConfig.value.outputRange);\n            interpolateConfig.value.cache.value = colors;\n        }\n        return interpolateColorsRGB(value, interpolateConfig.value.inputRange, colors, interpolateConfig.value.options);\n    }\n    else if (interpolateConfig.value.colorSpace === ColorSpace.HSV) {\n        if (!colors) {\n            colors = getInterpolateHSV(interpolateConfig.value.outputRange);\n            interpolateConfig.value.cache.value = colors;\n        }\n        return interpolateColorsHSV(value, interpolateConfig.value.inputRange, colors, interpolateConfig.value.options);\n    }\n    throw new Error(`Invalid color space provided: ${interpolateConfig.value.colorSpace}. Supported values are: ['RGB', 'HSV']`);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}